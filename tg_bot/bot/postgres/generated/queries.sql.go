// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTranscribition = `-- name: CreateTranscribition :one
INSERT INTO transcribitions (
  tg_user_id,
  message_to_edit
) VALUES (
  $1, $2
)
RETURNING id
`

type CreateTranscribitionParams struct {
	TgUserID      int64
	MessageToEdit pgtype.Int8
}

func (q *Queries) CreateTranscribition(ctx context.Context, arg CreateTranscribitionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTranscribition, arg.TgUserID, arg.MessageToEdit)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (
  tg_user_id 
) VALUES (
  $1
)
ON CONFLICT(tg_user_id) 
DO NOTHING
`

func (q *Queries) CreateUser(ctx context.Context, tgUserID int64) error {
	_, err := q.db.Exec(ctx, createUser, tgUserID)
	return err
}

const getTranscribition = `-- name: GetTranscribition :one
SELECT id, tg_user_id, audio_name_minio, audio_bucket_minio, formal_report_minio, informal_report_minio, transcription, status, created_at, llama_output, message_to_edit FROM transcribitions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTranscribition(ctx context.Context, id int64) (Transcribition, error) {
	row := q.db.QueryRow(ctx, getTranscribition, id)
	var i Transcribition
	err := row.Scan(
		&i.ID,
		&i.TgUserID,
		&i.AudioNameMinio,
		&i.AudioBucketMinio,
		&i.FormalReportMinio,
		&i.InformalReportMinio,
		&i.Transcription,
		&i.Status,
		&i.CreatedAt,
		&i.LlamaOutput,
		&i.MessageToEdit,
	)
	return i, err
}

const getTranscribitions = `-- name: GetTranscribitions :many
SELECT id, tg_user_id, audio_name_minio, audio_bucket_minio, formal_report_minio, informal_report_minio, transcription, status, created_at, llama_output, message_to_edit FROM transcribitions
`

func (q *Queries) GetTranscribitions(ctx context.Context) ([]Transcribition, error) {
	rows, err := q.db.Query(ctx, getTranscribitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transcribition
	for rows.Next() {
		var i Transcribition
		if err := rows.Scan(
			&i.ID,
			&i.TgUserID,
			&i.AudioNameMinio,
			&i.AudioBucketMinio,
			&i.FormalReportMinio,
			&i.InformalReportMinio,
			&i.Transcription,
			&i.Status,
			&i.CreatedAt,
			&i.LlamaOutput,
			&i.MessageToEdit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT tg_user_id, current_bot_status, current_bot_id FROM users
WHERE tg_user_id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, tgUserID int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, tgUserID)
	var i User
	err := row.Scan(&i.TgUserID, &i.CurrentBotStatus, &i.CurrentBotID)
	return i, err
}

const updateCurrentBotID = `-- name: UpdateCurrentBotID :exec
UPDATE users
SET current_bot_id = $1
WHERE tg_user_id = $2
`

type UpdateCurrentBotIDParams struct {
	CurrentBotID pgtype.Int8
	TgUserID     int64
}

func (q *Queries) UpdateCurrentBotID(ctx context.Context, arg UpdateCurrentBotIDParams) error {
	_, err := q.db.Exec(ctx, updateCurrentBotID, arg.CurrentBotID, arg.TgUserID)
	return err
}

const updateCurrentBotStatus = `-- name: UpdateCurrentBotStatus :exec
UPDATE users
SET current_bot_status = $1
WHERE tg_user_id = $2
`

type UpdateCurrentBotStatusParams struct {
	CurrentBotStatus pgtype.Text
	TgUserID         int64
}

func (q *Queries) UpdateCurrentBotStatus(ctx context.Context, arg UpdateCurrentBotStatusParams) error {
	_, err := q.db.Exec(ctx, updateCurrentBotStatus, arg.CurrentBotStatus, arg.TgUserID)
	return err
}

const updateLlamaOutput = `-- name: UpdateLlamaOutput :exec
UPDATE transcribitions
SET llama_output = $1
WHERE id = $2
`

type UpdateLlamaOutputParams struct {
	LlamaOutput pgtype.Text
	ID          int64
}

func (q *Queries) UpdateLlamaOutput(ctx context.Context, arg UpdateLlamaOutputParams) error {
	_, err := q.db.Exec(ctx, updateLlamaOutput, arg.LlamaOutput, arg.ID)
	return err
}

const updateMinioLink = `-- name: UpdateMinioLink :exec
UPDATE transcribitions
SET audio_name_minio = $1,
    audio_bucket_minio = $2
WHERE id = $3
`

type UpdateMinioLinkParams struct {
	AudioNameMinio   pgtype.Text
	AudioBucketMinio pgtype.Text
	ID               int64
}

func (q *Queries) UpdateMinioLink(ctx context.Context, arg UpdateMinioLinkParams) error {
	_, err := q.db.Exec(ctx, updateMinioLink, arg.AudioNameMinio, arg.AudioBucketMinio, arg.ID)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE transcribitions
SET status = $1
WHERE id = $2
`

type UpdateStatusParams struct {
	Status pgtype.Int4
	ID     int64
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.Status, arg.ID)
	return err
}

const updateTranscription = `-- name: UpdateTranscription :exec
UPDATE transcribitions
SET transcription = $1
WHERE id = $2
`

type UpdateTranscriptionParams struct {
	Transcription pgtype.Text
	ID            int64
}

func (q *Queries) UpdateTranscription(ctx context.Context, arg UpdateTranscriptionParams) error {
	_, err := q.db.Exec(ctx, updateTranscription, arg.Transcription, arg.ID)
	return err
}
